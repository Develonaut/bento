# Bento Desktop - Wails Implementation Strategy

**Date:** 2025-10-22
**Status:** Strategy Approved, Ready for Implementation
**Framework:** Wails v3 + React + TypeScript

---

## Executive Summary

This strategy outlines the implementation of a React-based desktop UI for Bento using the Wails framework. Wails was selected for its purpose-built Go+React integration, small binary size (~10-15MB), and seamless type-safe communication between Go and JavaScript.

---

## Recommendation: Wails v3

### Why Wails?

| Criterion | Wails | Electron | Tauri |
|-----------|-------|----------|-------|
| Binary Size | 10-15MB ✅ | 150-200MB ❌ | 25-30MB ⚠️ |
| Go Integration | Native ✅ | Via IPC ⚠️ | Via Sidecar ⚠️ |
| Type Safety | Auto-generated TS ✅ | Manual ⚠️ | Manual ⚠️ |
| Startup Time | <50ms ✅ | ~500ms ❌ | <100ms ✅ |
| Learning Curve | Medium ✅ | Easy ✅ | Hard ❌ |
| Bento Alignment | High ✅ | Low ❌ | Medium ⚠️ |

**Winner:** Wails aligns perfectly with Bento's goals of small binaries, fast performance, and Go-first architecture.

---

## Key Architecture

### Three-Layer Design

```
┌─────────────────────────────────────────────────────┐
│         Bento Desktop Application (Single Binary)    │
├─────────────────────────────────────────────────────┤
│  Layer 1: React Frontend (Vite + TypeScript)         │
│  ├─ WorkflowEditor.tsx                               │
│  ├─ WorkflowRunner.tsx                               │
│  ├─ NodeLibrary.tsx                                  │
│  └─ ExecutionViewer.tsx                              │
│                                                       │
│  Communication: window.backend.MethodName()          │
├─────────────────────────────────────────────────────┤
│  Layer 2: Wails Bridge                               │
│  ├─ Auto-generated TypeScript definitions            │
│  ├─ Method binding (Go → JavaScript)                 │
│  ├─ Event system (runtime.EventsEmit)                │
│  └─ Type safety enforcement                          │
├─────────────────────────────────────────────────────┤
│  Layer 3: Go Backend (100% Existing Bento Packages)  │
│  ├─ neta/ (workflow nodes)                           │
│  ├─ itamae/ (orchestration engine)                   │
│  ├─ pantry/ (node registry)                          │
│  ├─ hangiri/ (storage)                               │
│  ├─ shoyu/ (logging)                                 │
│  └─ omakase/ (validation)                            │
│                                                       │
│  NEW: internal/desktop/ (Wails bridge adapters)      │
├─────────────────────────────────────────────────────┤
│  Native WebView (OS-Provided)                        │
│  ├─ Windows: WebView2 (Chromium-based)               │
│  ├─ macOS: WebKit                                    │
│  └─ Linux: WebKitGTK                                 │
└─────────────────────────────────────────────────────┘
```

### Directory Structure

```
bento/
├── cmd/
│   ├── bento/                  # Existing CLI (unchanged)
│   └── bento-desktop/          # NEW: Wails desktop app
│       ├── main.go             # Wails entry point
│       ├── app.go              # App struct with exported methods
│       ├── build/              # Build artifacts
│       └── frontend/           # React application
│           ├── src/
│           │   ├── components/
│           │   ├── hooks/
│           │   ├── services/
│           │   ├── App.tsx
│           │   └── main.tsx
│           ├── wailsjs/        # Auto-generated by Wails
│           │   └── go/         # TypeScript bindings
│           ├── package.json
│           └── vite.config.ts
│
├── internal/
│   └── desktop/                # NEW: Desktop-specific logic
│       ├── workflows/          # Workflow management
│       ├── settings/           # Settings persistence
│       └── events/             # Event handling
│
└── pkg/                        # Existing packages (UNCHANGED)
    ├── neta/
    ├── itamae/
    ├── pantry/
    └── ...
```

---

## Hybrid Approach: Three Interfaces, One Codebase

### Strategy

Instead of replacing the CLI, **add desktop UI as a complementary interface**:

```
┌────────────────────────────────────────────┐
│      Bento Core Packages (pkg/)            │
│   Shared: neta, itamae, pantry, etc.       │
└────────────────────────────────────────────┘
                    │
      ┌─────────────┼─────────────┐
      │             │             │
  ┌───▼───┐    ┌───▼───┐    ┌────▼────┐
  │  CLI  │    │  TUI  │    │ Desktop │
  │(Cobra)│    │(Charm)│    │ (Wails) │
  └───────┘    └───────┘    └─────────┘
```

### Use Cases

| Interface | Target User | Primary Use Case |
|-----------|-------------|------------------|
| **CLI** | Developers, CI/CD | Automation, scripting, headless execution |
| **TUI** | Terminal Power Users | Quick edits, monitoring, SSH sessions |
| **Desktop** | Visual Users | Workflow authoring, visual editing, debugging |

### Benefits

- **Maximum Flexibility**: Users choose their preferred interface
- **Code Reuse**: All interfaces share the same execution engine
- **Progressive Enhancement**: Start with CLI, add GUI when needed
- **Minimal Duplication**: Core logic stays in pkg/, UIs are thin layers

---

## Go ↔ React Communication

### Go Backend (app.go)

```go
package main

import (
    "context"
    "github.com/yourusername/bento/pkg/itamae"
    "github.com/yourusername/bento/pkg/neta"
)

type App struct {
    ctx context.Context
}

func NewApp() *App {
    return &App{}
}

// Exported methods automatically available in JavaScript
func (a *App) LoadWorkflow(path string) (*neta.Definition, error) {
    return hangiri.Load(path)
}

func (a *App) RunWorkflow(path string) (string, error) {
    def, err := a.LoadWorkflow(path)
    if err != nil {
        return "", err
    }

    result, err := itamae.Execute(a.ctx, def)
    return result.ID, err
}

func (a *App) GetNodeTypes() []string {
    return pantry.ListTypes()
}
```

### React Frontend (TypeScript)

```typescript
// Auto-generated by Wails (wailsjs/go/main/App.ts)
import { LoadWorkflow, RunWorkflow, GetNodeTypes } from '../wailsjs/go/main/App'
import { neta } from '../wailsjs/go/models'

// React Component
function WorkflowRunner() {
    const [workflow, setWorkflow] = useState<neta.Definition | null>(null)

    const loadWorkflow = async (path: string) => {
        try {
            const def = await LoadWorkflow(path)  // Type-safe!
            setWorkflow(def)
        } catch (err) {
            console.error(err)
        }
    }

    const runWorkflow = async () => {
        const executionID = await RunWorkflow(workflow.path)
        console.log('Execution started:', executionID)
    }

    return (
        <div>
            <button onClick={() => loadWorkflow('/path/to/workflow.bento.json')}>
                Load
            </button>
            <button onClick={runWorkflow}>Run</button>
        </div>
    )
}
```

### Event System (Real-time Updates)

```go
// Go Backend - Emit events
import "github.com/wailsapp/wails/v2/pkg/runtime"

func (a *App) RunWorkflowWithProgress(path string) error {
    // ... execution logic

    // Emit progress events
    runtime.EventsEmit(a.ctx, "execution:progress", map[string]interface{}{
        "executionID": executionID,
        "progress":    0.5,
        "message":     "Processing item 50/100",
    })

    return nil
}
```

```typescript
// React Frontend - Listen for events
import { EventsOn } from '../wailsjs/runtime/runtime'

useEffect(() => {
    const unlisten = EventsOn('execution:progress', (data) => {
        console.log('Progress:', data.progress, data.message)
        setProgress(data.progress)
    })

    return () => unlisten()
}, [])
```

---

## Implementation Phases

### Overview

| Phase | Duration | Focus | Deliverable |
|-------|----------|-------|-------------|
| **Phase 1** | 1-2 weeks | POC Setup | Basic workflow runner |
| **Phase 2** | 3-4 weeks | Core Features | File browser, execution, logs |
| **Phase 3** | 5-6 weeks | Workflow Editor | Visual editor with drag-drop |
| **Phase 4** | 2 weeks | Polish & Distribution | Distributable binaries |
| **Total** | 14 weeks | | Production-ready desktop app |

### Phase Documents

Each phase has a detailed document with specific tasks, acceptance criteria, and Colossus review prompts:

1. **[wails-phase1-poc.md](./wails-phase1-poc.md)**
   - Wails project setup
   - Basic Go ↔ React communication
   - Single workflow runner UI
   - Validate architecture

2. **[wails-phase2-core-features.md](./wails-phase2-core-features.md)**
   - Workflow file browser
   - Execution with live progress
   - Log viewer with filtering
   - Node library browser

3. **[wails-phase3-workflow-editor.md](./wails-phase3-workflow-editor.md)**
   - Visual workflow canvas (React Flow)
   - Node palette (drag-drop)
   - Property editor
   - Real-time validation

4. **[wails-phase4-polish-distribution.md](./wails-phase4-polish-distribution.md)**
   - Settings & preferences
   - System tray integration
   - Cross-platform builds
   - Distribution packages

---

## Bento Box Principle Compliance

### Single Responsibility ✅

Each component has one purpose:
- `cmd/bento-desktop/app.go` - Wails bridge methods only
- `internal/desktop/workflows/` - Desktop workflow management only
- `frontend/src/components/WorkflowEditor.tsx` - Visual editing only

### No Utility Grab Bags ✅

```go
// ✅ GOOD - Organized by domain
internal/desktop/
├── workflows/
│   └── manager.go          # Workflow operations for desktop
├── settings/
│   └── preferences.go      # Desktop preferences
└── events/
    └── emitter.go          # Event emission logic

// ❌ BAD - Avoid this
internal/desktop/
└── utils/
    └── helpers.go          # Everything mixed together
```

### Clear Boundaries ✅

```go
// Layer 1: Wails Bridge (internal/desktop/bridge/)
type WorkflowBridge struct {
    manager *workflows.Manager
}

func (b *WorkflowBridge) LoadWorkflow(path string) (*neta.Definition, error) {
    return b.manager.Load(path)
}

// Layer 2: Desktop Logic (internal/desktop/workflows/)
type Manager struct {
    storage *hangiri.Hangiri
}

func (m *Manager) Load(path string) (*neta.Definition, error) {
    return m.storage.Load(path)
}

// Layer 3: Core Packages (pkg/hangiri/)
func (h *Hangiri) Load(path string) (*neta.Definition, error) {
    // Core storage logic (unchanged)
}
```

### Composable ✅

Desktop app composes existing Bento packages without modifying them.

### YAGNI ✅

Only build what's needed for each phase. No future-proofing.

---

## Testing Strategy

### Unit Tests

```go
// Core packages (existing, unchanged)
pkg/itamae/executor_test.go
pkg/neta/library/http/http_test.go

// Desktop-specific logic
internal/desktop/workflows/manager_test.go
internal/desktop/settings/preferences_test.go
```

### Integration Tests

```go
// Wails bridge integration
cmd/bento-desktop/app_test.go

func TestAppLoadWorkflow(t *testing.T) {
    app := NewApp()
    def, err := app.LoadWorkflow("testdata/simple.bento.json")
    assert.NoError(t, err)
    assert.Equal(t, "simple-workflow", def.ID)
}
```

### Frontend Tests

```typescript
// React component tests (Jest + React Testing Library)
frontend/src/components/__tests__/WorkflowRunner.test.tsx

describe('WorkflowRunner', () => {
    it('loads and displays workflow', async () => {
        render(<WorkflowRunner />)
        // ... test assertions
    })
})
```

---

## Build & Distribution

### Development

```bash
# Install Wails CLI
go install github.com/wailsapp/wails/v2/cmd/wails@latest

# Initialize project (Phase 1)
cd cmd
wails init -n bento-desktop -t react-ts

# Development mode (hot reload)
cd cmd/bento-desktop
wails dev

# Frontend only (fast refresh)
cd frontend
npm run dev
```

### Production Builds

```bash
# Build for current platform
wails build

# Cross-platform builds
wails build -platform darwin/amd64,darwin/arm64
wails build -platform windows/amd64
wails build -platform linux/amd64
```

### Makefile Integration

```makefile
# Makefile additions
.PHONY: dev-desktop build-desktop build-desktop-all

dev-desktop:
	cd cmd/bento-desktop && wails dev

build-desktop:
	cd cmd/bento-desktop && wails build

build-desktop-all:
	cd cmd/bento-desktop && \
	wails build -platform darwin/universal && \
	wails build -platform windows/amd64 && \
	wails build -platform linux/amd64

release-all: build build-desktop-all
	# Package CLI + Desktop binaries
```

---

## Risk Assessment

### Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Wails learning curve | Medium | Medium | Start with POC, validate early |
| WebView inconsistencies | Low | Medium | Test on all platforms in Phase 1 |
| Binary size creep | Low | Low | Monitor builds, profile assets |
| Type generation issues | Low | Medium | Use Wails validation tools |

### Strategic Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Maintenance burden | High | Medium | Keep desktop code isolated in internal/desktop |
| User confusion (3 UIs) | Medium | Low | Clear docs, distinct use cases |
| Feature duplication | Medium | Medium | Share core packages, different UIs only |
| TUI vs Desktop conflict | Low | High | Position as complementary, not competing |

---

## Success Criteria

### Phase 1 Success
- [ ] Wails project builds successfully
- [ ] Can call Go method from React
- [ ] Can run a workflow from UI
- [ ] Binary size < 20MB

### Phase 2 Success
- [ ] Can browse and load workflow files
- [ ] Can execute workflows with live progress
- [ ] Can view logs with filtering
- [ ] Can browse node library

### Phase 3 Success
- [ ] Can create workflows visually
- [ ] Can drag-drop nodes onto canvas
- [ ] Can edit node properties
- [ ] Can validate workflows in real-time

### Phase 4 Success
- [ ] Cross-platform builds working
- [ ] Settings persist correctly
- [ ] System tray integration works
- [ ] Distributable packages created

---

## Decision Points

### Before Starting Phase 1
- [ ] Confirm React UI is required (vs Charm TUI only)
- [ ] Confirm Wails is approved framework
- [ ] Align with TUI roadmap (complementary vs replacement)
- [ ] Allocate development resources (14 weeks)

### After Phase 1 (POC)
- [ ] Evaluate Wails developer experience
- [ ] Validate Go ↔ React communication works well
- [ ] Confirm binary size is acceptable
- [ ] Decision: Proceed to Phase 2 or pivot?

### After Phase 2 (Core Features)
- [ ] Gather user feedback on basic UI
- [ ] Evaluate performance with real workflows
- [ ] Decision: Continue to visual editor or iterate on core?

### After Phase 3 (Visual Editor)
- [ ] Validate visual editor meets user needs
- [ ] Assess feature completeness
- [ ] Decision: Polish for release or add features?

---

## Next Steps

1. **Review this strategy document**
   - Confirm approach aligns with Bento goals
   - Confirm 14-week timeline is acceptable
   - Confirm Wails is approved

2. **Read phase documents**
   - [Phase 1: POC Setup](./wails-phase1-poc.md)
   - [Phase 2: Core Features](./wails-phase2-core-features.md)
   - [Phase 3: Workflow Editor](./wails-phase3-workflow-editor.md)
   - [Phase 4: Polish & Distribution](./wails-phase4-polish-distribution.md)

3. **Install prerequisites**
   ```bash
   # Wails CLI
   go install github.com/wailsapp/wails/v2/cmd/wails@latest

   # Wails doctor (check system deps)
   wails doctor
   ```

4. **Begin Phase 1**
   - Start with POC implementation
   - Use Colossus to implement with code reviews
   - Validate architecture before proceeding

---

## Resources

### Official Documentation
- Wails Docs: https://wails.io/docs/introduction/
- Wails GitHub: https://github.com/wailsapp/wails
- React Flow (for visual editor): https://reactflow.dev/

### Bento Documentation
- Bento Box Principle: `.claude/BENTO_BOX_PRINCIPLE.md`
- Go Standards Review: `.claude/GO_STANDARDS_REVIEW.md`
- Package Naming: `.claude/PACKAGE_NAMING.md`

### Code Review
- Review Checklist: `.claude/workflow/REVIEW_CHECKLIST.md`
- Code Review Command: `.claude/commands/code-review.md`

---

**Status:** Strategy complete, ready for Phase 1
**Approved by:** Awaiting approval
**Next Action:** Review and approve, then begin Phase 1 POC
